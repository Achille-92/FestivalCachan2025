#include <Arduino.h>
#include <Wire.h>
#include <ESP32Servo.h>
#include "rgb_lcd.h"
#include <BluetoothSerial.h>
#include "Vl53l0x.h"

#define PIN_SG90 27

#define PIN_MoteurGauche 25
#define PIN_MoteurDroit 4
#define PIN_SensMoteurGauche 26
#define PIN_SensMoteurDroit 23

#define PIN_CNY70_ExGauche 39
#define PIN_CNY70_Gauche 34
#define PIN_CNY70_Milieu 35
#define PIN_CNY70_Droit 32
#define PIN_CNY70_ExDroit 33

#define PIN_BP1 12
#define PIN_BP2 14
#define PIN_Pot 36
#define PIN_FDC 13

void lecture_capteur(void);
int potentiometre(void);
void CompteLigne(void);
void Droite(void);
void Gauche(void);
void RouleMaPoule(void);
int DemarageAutomatique(void);

rgb_lcd lcd;
BluetoothSerial SerialBT;
Servo sg90;
Vl53l0x TOF;

int val_TOF = 0;
int tab_capteur[5] = {0,0,0,0,0};                                           // Déclaration des tableaux pour les valeurs lues des CNY70
int tab_min[5] = {4096,4096,4096,4096,4096};                                // Déclaration des tableaux pour les valeurs MIN des CNY70
int tab_max[5] = {0,0,0,0,0};                                               // Déclaration des tableaux pour les valeurs MAX des CNY70
int tab_capteur_norm[5] = {0, 0, 0 ,0 ,0};                     // Déclaration des tableaux pour les valeurs normalisées des CNY70

int frequence = 500;
int canal0 = 0;
int canal1 = 1;
int canal2 = 2;
int resolution = 10;

int etat_course = 0;
int pos_ligne = 0;
int PWMGauche = 0;
int PWMDroit = 0;

int v_base = 400; // V MAX = 1024
int pos, ancienne_pos = 0, cmd;

int val_BP1 = 0, val_BP2 = 0; 
int val_pot;
float KP = 3.6;
float KD = 5;
int menu = 0, menu1 = 0, Lig = 0, Lid = 0, Clig = 0, Clid = 0, fdc=0, add=0,Dem=0,i=0;
char caractere = 0;
int old_val_ExG,old_val_ExD;

void setup() {
  Serial.begin(115200);
  lcd.begin(16, 2);                   // définition du format de l'écran
  lcd.setRGB(255,255,255); // définition du rapport de couleur pour le rétroéclairage
  SerialBT.begin("WALL-E");
  /*
  sg90.setPeriodHertz(50); // Fréquence PWM pour le SG90
  sg90.attach(PIN_SG90, 500, 2400); // Largeur minimale et maximale de l'impulsion (en µs) pour aller de 0° à 180°
  sg90.write(0);*/
  // Setup CNY70 //
  pinMode(PIN_CNY70_ExGauche,INPUT);
  pinMode(PIN_CNY70_Gauche,INPUT);
  pinMode(PIN_CNY70_Milieu,INPUT);
  pinMode(PIN_CNY70_Droit,INPUT);
  pinMode(PIN_CNY70_ExDroit,INPUT);
  /////////////////

  // Setup PWM //
  ledcSetup(canal2,frequence,resolution);
  ledcSetup(canal1,frequence,resolution);
  ledcAttachPin(PIN_MoteurGauche, canal2);
  ledcAttachPin(PIN_MoteurDroit, canal1);
  pinMode(PIN_SensMoteurDroit,OUTPUT);
  pinMode(PIN_SensMoteurGauche,OUTPUT);
  digitalWrite(PIN_SensMoteurDroit,LOW);
  digitalWrite(PIN_SensMoteurGauche,HIGH);
  ledcWrite(canal2,0);
  ledcWrite(canal1,0);
  ///////////////

  pinMode(PIN_BP1, INPUT_PULLDOWN);
  pinMode(PIN_BP2, INPUT_PULLDOWN);
  pinMode(PIN_Pot, INPUT);
  pinMode(PIN_FDC, INPUT);

  ledcWrite(canal2,0);
  ledcWrite(canal1,0);
}

void loop(){ 
  menu = val_pot/10;
  val_BP1 = digitalRead(PIN_BP1);
  Serial.printf("BP1=%1d",val_BP1);
  val_BP2 = digitalRead(PIN_BP2);
  Serial.printf("BP2=%1d",val_BP2);
  val_pot = potentiometre();
  Serial.printf("potentiomètre=%3d",val_pot);
  fdc = digitalRead(PIN_FDC);
  Serial.printf("FDC=%1d",fdc);
  if (fdc != 0)etat_course=2;
  sg90.write(90);

  lecture_capteur();
  if (menu != menu1){
    menu1 = menu;
    lcd.clear();
  }
  switch (menu){
    case 0:
      lcd.setCursor(0,0);
      lcd.printf("MenuModif");
      lcd.setCursor(0,1);
      lcd.printf("Etalonage");
      // Lecture des valeurs analogiques des 5 CNY70 /////////////////////////
      tab_capteur[0] =  analogRead(PIN_CNY70_ExGauche);
      tab_capteur[1] = analogRead(PIN_CNY70_Gauche);
      tab_capteur[2] = analogRead(PIN_CNY70_Milieu);
      tab_capteur[3] = analogRead(PIN_CNY70_Droit);
      tab_capteur[4] = analogRead(PIN_CNY70_ExDroit);  
      // Étalonnage des capteurs pour récupérer les valeurs Min et Max entre 0 et 1023
      for(i=0; i<5; i++){                                     // On répéte 5 fois, et i prends les valeurs 0, 1, 2, 3 et 4
        if(tab_capteur[i] > tab_max[i]){                    // Si la valeur du CNY70, à l'indice i, est supérieure à son ancienne valeur max 
            tab_max[i] = tab_capteur[i];                    //      Alors la valeur du CNY70, à l'indice i, devient la nouvelle valeur max du capteur 
        }
        if(tab_capteur[i] < tab_min[i]){                    // Si la valeur du CNY70, à l'indice i, est inférieure à son ancienne valeur min 
            tab_min[i] = tab_capteur[i];                    //      Alors la valeur du CNY70, à l'indice i, devient la nouvelle valeur min du capteur 
        }
      }
      if(val_BP1==2){
        for(i=0; i<5; i++){                                     // On répéte 5 fois, et i prends les valeurs 0, 1, 2, 3 et 4
          tab_max[i] = 0;                    //      Alors la valeur du CNY70, à l'indice i, devient la nouvelle valeur max du capteur 
          tab_min[i] = 4096;                    //      Alors la valeur du CNY70, à l'indice i, devient la nouvelle valeur min du capteur 
        }
      }
      break;
    case 1:
      lcd.setCursor(0,0);
      lcd.printf("KP:%1.2f",KP);
      lcd.setCursor(0,1);
      lcd.printf("Pot:%d",val_pot);
      if(val_BP2==1){
        while(val_BP1==0){
          val_BP1 = digitalRead(PIN_BP1);
          val_BP2 = digitalRead(PIN_BP2);
          lcd.setCursor(0,0);
          lcd.printf("KP:%1.2f",KP);
          lcd.setCursor(0,1);
          lcd.printf("Pot:%d",val_pot);
          val_pot = potentiometre();
          KP=(float)val_pot/10.0;
        }
        delay(100);
        val_BP1 = 0;
        val_BP2 = 0;
      }
      break;
    case 2:
      lcd.setCursor(0,0);
      lcd.printf("KD:%2.2f",KD);
      lcd.setCursor(0,1);
      lcd.printf("Pot:%d",val_pot);
      if(val_BP2==1){
        while(val_BP1==0){
          val_BP1 = digitalRead(PIN_BP1);
          val_BP2 = digitalRead(PIN_BP2);
          lcd.setCursor(0,0);
          lcd.printf("KD:%2.2f",KD);
          lcd.setCursor(0,1);
          lcd.printf("Pot:%d",val_pot);
          val_pot = potentiometre();
          KD=(float)val_pot/5;
        }
        delay(100);
        val_BP1 = 0;
        val_BP2 = 0;
      }
      break;
    case 3:
      lcd.setCursor(0, 0);
      lcd.printf("DemarageAuto");
      lcd.setCursor(0, 1);
      lcd.printf("Fait: %d",Dem);
      /*if(val_BP1==1){
        Dem = DemarageAutomatique();
      }*/
      break;
    case 4:
      lcd.setCursor(0, 0);
      lcd.printf("etat:%1d Lid:%2d",etat_course,Lid);
      lcd.setCursor(0, 1);
      lcd.printf("pos:%3dadd:%3d",pos,add);
      break;
    case 5:
      lcd.setCursor(0, 0);
      lcd.printf("CedN:%3dCidN:%3d",tab_capteur_norm[4],tab_capteur_norm[3]);
      lcd.setCursor(0, 1);
      lcd.printf("CegN:%3dCigN:%3d",tab_capteur_norm[0],tab_capteur_norm[1]);
      break;
    case 6:
      lcd.setCursor(0, 0);
      lcd.printf("Ced:%4dCid:%4d",tab_capteur[4],tab_capteur[3]);
      lcd.setCursor(0, 1);
      lcd.printf("Ceg:%4dCig:%4d",tab_capteur[0],tab_capteur[1]);
      Serial.printf("Ced:%4d Cid:%4d Ceg:%4d Cig:%4d",tab_capteur[4],tab_capteur[3],tab_capteur[0],tab_capteur[1]);
      break;
  }

  switch (etat_course){
  case 0: 
    if(val_BP1 == 1 & val_BP2 == 1){
      etat_course = 1;
    }
    if (SerialBT.available()) // vérification de l'appui d'une touche
    {
      caractere = SerialBT.read(); // enregistrement de la touche presser
      Serial.printf("C=%c",caractere);
      if (caractere == 'D')etat_course = 1; //prêt à démarer
    }
    PWMGauche = 0;
    PWMDroit = 0;
    break;
  
    case 1: // Suivi de ligne
      switch(pos_ligne){
        case 0 :                                                              // Le robot est centré sur la ligne           
          // if (tab_capteur_norm[2] < 70 && tab_capteur_norm[3] > 30) pos_ligne = 1;   // Si le robot est trop à Gauche de la ligne, on passe à l'état 1
          // if (tab_capteur_norm[2] < 70 && tab_capteur_norm[1] > 30) pos_ligne = 2;   // Si le robot est trop à Droite de la ligne, on passe à l'état 2          
          CompteLigne();
          RouleMaPoule();
          
          break;
        case 1 :                                                          // Le robot est trop à Gauche de la ligne
            PWMGauche = 512;                                              // Le moteur Gauche tourne plus vite (moitié vitesse max)
            PWMDroit = 170;                                               // Le moteur Droit tourne moins vite (1/6 vitesse max)
            if (tab_capteur_norm[2] <15) pos_ligne = 0;                  // Si le robot détecte de nouveau la ligne, on passe à l'état 0
            break;
        case 2 :                                                          // Le robot est trop à Droite de la ligne
            PWMGauche = 170;                                              // Le moteur Gauche tourne moins vite (1/6 vitesse max)
            PWMDroit = 512;                                               // Le moteur Droit tourne plus vite (moitié vitesse max)
            if (tab_capteur_norm[2] <15) pos_ligne = 0;                  // Si le robot détecte de nouveau la ligne, on passe à l'état 0
            break;
      }
      break;
    case 2:
      PWMGauche = 0;
      PWMDroit = 0;
      if(val_BP2==1)etat_course=0;
      if (SerialBT.available()) // vérification de l'appui d'une touche
      {
        caractere = SerialBT.read(); // enregistrement de la touche presser
        Serial.printf("C=%c",caractere);
        if (caractere == 'R')etat_course = 0; //prêt à démarer
      }
    break;
    default :
      PWMGauche = 0;   //arret par defaut
      PWMDroit = 0;
    break;
  }
  if(PWMGauche>1024)PWMGauche=1024;  //saturation des moteurs
  if(PWMDroit>1024)PWMDroit=1024;
  if(PWMGauche<0)PWMGauche=0;
  if(PWMDroit<0)PWMDroit=0;
  ledcWrite(canal2,PWMDroit);
  ledcWrite(canal1,PWMGauche);
  Serial.printf(" etat_course=%1d\n",etat_course);
}

void lecture_capteur(void){
  tab_capteur[0] =  analogRead(PIN_CNY70_ExGauche);
  tab_capteur[1] = analogRead(PIN_CNY70_Gauche);
  tab_capteur[2] = analogRead(PIN_CNY70_Milieu);
  tab_capteur[3] = analogRead(PIN_CNY70_Droit);
  tab_capteur[4] = analogRead(PIN_CNY70_ExDroit);  
  // Normalisation des capteurs grâce à la relation du cours /////////////
  for(i=0; i<5; i++){
    tab_capteur_norm[i] = 100.0*((float)tab_capteur[i] - (float)tab_min[i])/((float)tab_max[i] - (float)tab_min[i]) ; // Valeur entre 0 et 100
  }
  ////////////////////////////////////////////////////////////////////////
  pos = tab_capteur_norm[1] - tab_capteur_norm[3];                  // Valeur Gauche - Droit
  add = tab_capteur_norm[1] + tab_capteur_norm[3];                 //Gauche + Droit
  if(add>125&&pos>0)pos = 100;                                //saturation de l'erreur
  if(add>125&&pos<0)pos = -100;
}
int potentiometre(void){
  int ValeurADC_Pot;
  int Pot;
  ValeurADC_Pot = analogRead(PIN_Pot);                                  // Lit la valeur analogique sur le bit 0
  Pot = ((float)ValeurADC_Pot/40.95);                                   // Calcule la valeur du potentiomètre entre 0 et 100
  return Pot;
}

void CompteLigne(void){
  if(tab_capteur_norm[0]<1000 && old_val_ExG > 1000){
    Lig++;
  }
  if(tab_capteur_norm[4]<1000 && old_val_ExD > 1000){
    Lid++;
  }
  old_val_ExG = tab_capteur_norm[0];
  old_val_ExD = tab_capteur_norm[4];
  /*
  if (Clid == 1 && tab_capteur_norm[4]>90)Lid++;
  if (tab_capteur[4]<10 && tab_capteur_norm[2]<10) Clid = 1;   //compteur de ligne à droite
  if (Clig == 1 && tab_capteur_norm[0]>90)Lig++;
  if (tab_capteur[0]<10 && tab_capteur_norm[2]<10) Clig = 1;   //compteur de ligne à gauche */ 
}

void Droite(void){
  PWMGauche = 200;                                              
  PWMDroit = 200; 
  digitalWrite(PIN_SensMoteurDroit,HIGH);
  digitalWrite(PIN_SensMoteurGauche,HIGH);
}

void Gauche(void){
  PWMGauche = 200;                                              
  PWMDroit = 200; 
  digitalWrite(PIN_SensMoteurDroit,LOW);
  digitalWrite(PIN_SensMoteurGauche,LOW);
}

void RouleMaPoule(void){
  digitalWrite(PIN_SensMoteurDroit,LOW);
  digitalWrite(PIN_SensMoteurGauche,HIGH);
  cmd = KP*pos + KD*(pos - ancienne_pos);  // Calcul de la valeur de l'ordre de correction avec Kp et Kd
  ancienne_pos = pos;                      // La valeur de 'ancienne pos' devient la valeur de la 'pos' actuelle, utile pour le calcul de d�riv�e
  PWMGauche = v_base - cmd;                // Calcul Vitesse Moteur Gauche
  PWMDroit = v_base + cmd;                 // Calcul Vitesse Moteur Droit    
}

int DemarageAutomatique(void){
 int etat = 0;
 Dem = 0;
 while(etat != 5)
 {
  tab_capteur[1] = analogRead(PIN_CNY70_Gauche);
  tab_capteur[2] = analogRead(PIN_CNY70_Milieu);
  tab_capteur[3] = analogRead(PIN_CNY70_Droit);
  tab_capteur[4] = analogRead(PIN_CNY70_ExDroit);  
    // Étalonnage des capteurs pour récupérer les valeurs Min et Max entre 0 et 1023
  for(i=0; i<5; i++){                                     // On répéte 5 fois, et i prends les valeurs 0, 1, 2, 3 et 4
    if(tab_capteur[i] > tab_max[i]){                    // Si la valeur du CNY70, à l'indice i, est supérieure à son ancienne valeur max 
        tab_max[i] = tab_capteur[i];                    //      Alors la valeur du CNY70, à l'indice i, devient la nouvelle valeur max du capteur 
    }
    if(tab_capteur[i] < tab_min[i]){                    // Si la valeur du CNY70, à l'indice i, est inférieure à son ancienne valeur min 
        tab_min[i] = tab_capteur[i];                    //      Alors la valeur du CNY70, à l'indice i, devient la nouvelle valeur min du capteur 
    }
  }
  if(val_BP1==1){
    for(i=0; i<5; i++){                                     // On répéte 5 fois, et i prends les valeurs 0, 1, 2, 3 et 4
        tab_max[i] = 0;                    //      Alors la valeur du CNY70, à l'indice i, devient la nouvelle valeur max du capteur 
        tab_min[i] = 4096;                    //      Alors la valeur du CNY70, à l'indice i, devient la nouvelle valeur min du capteur 
  }
  lcd.setCursor(0, 0);
  lcd.printf("DemarageAuto");
  lcd.setCursor(0, 1);
  lcd.printf("Fait:%d etat:%d",Dem,etat);
    switch(etat)
    {
      case 0:
        PWMGauche = 200;
        PWMDroit = 200;
        lecture_capteur();
        if(tab_capteur[2]<200)etat=1;
      break;
      case 1:
        PWMGauche = 200;
        PWMDroit = 200;
        lecture_capteur();
        if(tab_capteur[2]>3500)etat=2;
      break;
      case 2:
        digitalWrite(PIN_SensMoteurDroit,HIGH);
        digitalWrite(PIN_SensMoteurGauche,LOW);
        PWMGauche = 200;
        PWMDroit = 200;
        lecture_capteur();
        CompteLigne();
        if(Lig==1&&Lid==1)etat=3,Lig=0,Lid=0;
      break;
      case 3:
        lecture_capteur();
        CompteLigne;
        digitalWrite(PIN_SensMoteurDroit,LOW);
        digitalWrite(PIN_SensMoteurGauche,HIGH);
        PWMGauche = 200;
        PWMDroit = 200;
        if(Lig==1&&Lid==1)etat=4,Lig=0,Lid=0;
      break;
      case 4:
        lecture_capteur();
        CompteLigne();
        Droite();
        if(Lid==1&&tab_capteur_norm[2]<20)etat=5,PWMGauche=0,PWMDroit=0;
      break;
      case 5:
        PWMDroit = 0;
        PWMGauche = 0;
      break;
      }
    ledcWrite(canal2,PWMDroit);
    ledcWrite(canal1,PWMGauche);
    } 
  }
  return 1;
}
